<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2575.6">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
  </style>
</head>
<body>
<p class="p1">&lt;!DOCTYPE html&gt;</p>
<p class="p1">&lt;html lang="es"&gt;</p>
<p class="p1">&lt;head&gt;</p>
<p class="p1">&lt;meta charset="utf-8"/&gt;</p>
<p class="p1">&lt;title&gt;KIMI v Grok – One-Shot Particle Attractor&lt;/title&gt;</p>
<p class="p1">&lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;</p>
<p class="p1">&lt;style&gt;html,body{margin:0;height:100%;overflow:hidden;background:#000}canvas{display:block}&lt;/style&gt;</p>
<p class="p1">&lt;/head&gt;</p>
<p class="p1">&lt;body&gt;</p>
<p class="p1">&lt;script type="importmap"&gt;</p>
<p class="p1">{</p>
<p class="p1"><span class="Apple-converted-space">  </span>"imports": {</p>
<p class="p1"><span class="Apple-converted-space">    </span>"three": "https://unpkg.com/three@0.164.1/build/three.module.js",</p>
<p class="p1"><span class="Apple-converted-space">    </span>"three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1">}</p>
<p class="p1">&lt;/script&gt;</p>
<p class="p1">&lt;script type="module"&gt;</p>
<p class="p1">/* ====== KIMI 1-PROMPT SHOWCASE ====== */</p>
<p class="p1">import * as THREE from 'three';</p>
<p class="p1">import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';</p>
<p class="p1">import { RenderPass } <span class="Apple-converted-space">      </span>from 'three/addons/postprocessing/RenderPass.js';</p>
<p class="p1">import { UnrealBloomPass }<span class="Apple-converted-space">  </span>from 'three/addons/postprocessing/UnrealBloomPass.js';</p>
<p class="p1">import { ShaderPass } <span class="Apple-converted-space">      </span>from 'three/addons/postprocessing/ShaderPass.js';</p>
<p class="p2"><br></p>
<p class="p1">/* ---- 1. escena y cámara ---- */</p>
<p class="p1">const scene<span class="Apple-converted-space">    </span>= new THREE.Scene();</p>
<p class="p1">const camera <span class="Apple-converted-space">  </span>= new THREE.PerspectiveCamera(60, innerWidth/innerHeight, .1, 100);</p>
<p class="p1">camera.position.set(0,0,45);</p>
<p class="p1">const renderer = new THREE.WebGLRenderer({ antialias:true });</p>
<p class="p1">renderer.setPixelRatio( devicePixelRatio );</p>
<p class="p1">renderer.setSize(innerWidth, innerHeight);</p>
<p class="p1">document.body.appendChild(renderer.domElement);</p>
<p class="p2"><br></p>
<p class="p1">/* ---- 2. partículas GPU ---- */</p>
<p class="p1">const COUNT<span class="Apple-converted-space">  </span>= 1_200_000;</p>
<p class="p1">const data <span class="Apple-converted-space">  </span>= new Float32Array(COUNT*4); // xyz + life</p>
<p class="p1">for(let i=0;i&lt;data.length;i+=4){ data[i]=Math.random()*2-1; data[i+1]=Math.random()*2-1; data[i+2]=Math.random()*2-1; data[i+3]=1; }</p>
<p class="p1">const texData = new THREE.DataTexture(data, COUNT, 1, THREE.RGBAFormat, THREE.FloatType);</p>
<p class="p1">texData.needsUpdate = true;</p>
<p class="p2"><br></p>
<p class="p1">const simMat = new THREE.ShaderMaterial({</p>
<p class="p1"><span class="Apple-converted-space">  </span>uniforms:{</p>
<p class="p1"><span class="Apple-converted-space">    </span>tPos:{ value:texData },</p>
<p class="p1"><span class="Apple-converted-space">    </span>uTime:{ value:0 },</p>
<p class="p1"><span class="Apple-converted-space">    </span>uShape:{ value:0 } // 0=Lorenz, 1=Rössler, 2=Aizawa</p>
<p class="p1"><span class="Apple-converted-space">  </span>},</p>
<p class="p1"><span class="Apple-converted-space">  </span>vertexShader:`#version 300 es</p>
<p class="p1"><span class="Apple-converted-space">  </span>in vec2 uv;</p>
<p class="p1"><span class="Apple-converted-space">  </span>out vec2 vUv;</p>
<p class="p1"><span class="Apple-converted-space">  </span>void main(){vUv=uv; gl_Position=vec4(uv*2.-1.,0,1);}</p>
<p class="p1"><span class="Apple-converted-space">  </span>`,</p>
<p class="p1"><span class="Apple-converted-space">  </span>fragmentShader:`#version 300 es</p>
<p class="p1"><span class="Apple-converted-space">  </span>precision highp float;</p>
<p class="p1"><span class="Apple-converted-space">  </span>uniform sampler2D tPos;</p>
<p class="p1"><span class="Apple-converted-space">  </span>uniform float uTime;</p>
<p class="p1"><span class="Apple-converted-space">  </span>uniform float uShape;</p>
<p class="p1"><span class="Apple-converted-space">  </span>in vec2 vUv;</p>
<p class="p1"><span class="Apple-converted-space">  </span>layout(location=0) out vec4 outPos;</p>
<p class="p1"><span class="Apple-converted-space">  </span>vec3 lorenz(vec3 p){ float dt=.005; float s=10.,r=28.,b=8./3.; return p+vec3(s*(p.y-p.x),p.x*(r-p.z)-p.y,p.x*p.y-b*p.z)*dt;}</p>
<p class="p1"><span class="Apple-converted-space">  </span>vec3 rossler(vec3 p){ float dt=.01; float a=.2,b=.2,c=5.7; return p+vec3(-p.y-p.z,p.x+a*p.y,b+p.z*(p.x-c))*dt;}</p>
<p class="p1"><span class="Apple-converted-space">  </span>vec3 aizawa(vec3 p){ float dt=.005; float a=.95,b=.7,c=.6,d=3.5,e=.25,f=.1; return p+vec3((p.z-b)*p.x-d*p.y, d*p.x+(p.z-b)*p.y, c+a*p.z-p.z*p.z*p.z/3 - (p.x*p.x+p.y*p.y)*(1+e*p.z)+f*p.z*(p.x*p.x*p.x))*dt;}</p>
<p class="p1"><span class="Apple-converted-space">  </span>void main(){</p>
<p class="p1"><span class="Apple-converted-space">    </span>vec4 p=texture(tPos,vUv);</p>
<p class="p1"><span class="Apple-converted-space">    </span>vec3 pos=p.xyz;</p>
<p class="p1"><span class="Apple-converted-space">    </span>if(uShape&lt;.5) pos=lorenz(pos);</p>
<p class="p1"><span class="Apple-converted-space">    </span>else if(uShape&lt;1.5) pos=rossler(pos);</p>
<p class="p1"><span class="Apple-converted-space">    </span>else pos=aizawa(pos);</p>
<p class="p1"><span class="Apple-converted-space">    </span>outPos=vec4(pos,p.w);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}`</p>
<p class="p1">});</p>
<p class="p1">const simQuad = new THREE.Mesh(new THREE.PlaneGeometry(2,2),simMat);</p>
<p class="p1">const simScene = new THREE.Scene();</p>
<p class="p1">const simCam <span class="Apple-converted-space">  </span>= new THREE.Camera();</p>
<p class="p1">simScene.add(simQuad);</p>
<p class="p2"><br></p>
<p class="p1">const rt1 = new THREE.WebGLRenderTarget(COUNT,1,{ type:THREE.FloatType, format:THREE.RGBAFormat });</p>
<p class="p1">const rt2 = new THREE.WebGLRenderTarget(COUNT,1,{ type:THREE.FloatType, format:THREE.RGBAFormat });</p>
<p class="p1">let write=rt1, read=rt2;</p>
<p class="p2"><br></p>
<p class="p1">/* ---- 3. visual ---- */</p>
<p class="p1">const visMat = new THREE.ShaderMaterial({</p>
<p class="p1"><span class="Apple-converted-space">  </span>uniforms:{</p>
<p class="p1"><span class="Apple-converted-space">    </span>tPos:{ value:rt1.texture },</p>
<p class="p1"><span class="Apple-converted-space">    </span>uTime:{ value:0 },</p>
<p class="p1"><span class="Apple-converted-space">    </span>uPoint:{ value:.015 },</p>
<p class="p1"><span class="Apple-converted-space">    </span>uColor:{ value:new THREE.Color("#00ffff") }</p>
<p class="p1"><span class="Apple-converted-space">  </span>},</p>
<p class="p1"><span class="Apple-converted-space">  </span>vertexShader:`#version 300 es</p>
<p class="p1"><span class="Apple-converted-space">  </span>in float index;</p>
<p class="p1"><span class="Apple-converted-space">  </span>uniform sampler2D tPos;</p>
<p class="p1"><span class="Apple-converted-space">  </span>uniform float uTime;</p>
<p class="p1"><span class="Apple-converted-space">  </span>void main(){</p>
<p class="p1"><span class="Apple-converted-space">    </span>vec4 p = texelFetch(tPos, ivec2(int(index),0), 0);</p>
<p class="p1"><span class="Apple-converted-space">    </span>vec3 pos = p.xyz * 8.;</p>
<p class="p1"><span class="Apple-converted-space">    </span>gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1);</p>
<p class="p1"><span class="Apple-converted-space">    </span>gl_PointSize = 1.8;</p>
<p class="p1"><span class="Apple-converted-space">  </span>}`,</p>
<p class="p1"><span class="Apple-converted-space">  </span>fragmentShader:`#version 300 es</p>
<p class="p1"><span class="Apple-converted-space">  </span>precision highp float;</p>
<p class="p1"><span class="Apple-converted-space">  </span>out vec4 fragColor;</p>
<p class="p1"><span class="Apple-converted-space">  </span>void main(){</p>
<p class="p1"><span class="Apple-converted-space">    </span>vec2 c = gl_PointCoord - .5;</p>
<p class="p1"><span class="Apple-converted-space">    </span>float alpha = 1.-length(c)*2.;</p>
<p class="p1"><span class="Apple-converted-space">    </span>if(alpha&lt;=0.) discard;</p>
<p class="p1"><span class="Apple-converted-space">    </span>fragColor = vec4(.1,1.,1.,alpha);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}`,</p>
<p class="p1"><span class="Apple-converted-space">  </span>transparent:true,</p>
<p class="p1"><span class="Apple-converted-space">  </span>depthTest:false,</p>
<p class="p1"><span class="Apple-converted-space">  </span>blending:THREE.AdditiveBlending</p>
<p class="p1">});</p>
<p class="p1">const geo = new THREE.BufferGeometry();</p>
<p class="p1">geo.setAttribute('index', new THREE.Float32BufferAttribute([...Array(COUNT).keys()],1));</p>
<p class="p1">const points = new THREE.Points(geo,visMat);</p>
<p class="p1">scene.add(points);</p>
<p class="p2"><br></p>
<p class="p1">/* ---- 4. post-proc ---- */</p>
<p class="p1">const composer = new EffectComposer(renderer);</p>
<p class="p1">composer.addPass(new RenderPass(scene,camera));</p>
<p class="p1">composer.addPass(new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight),1.2,.4,.75));</p>
<p class="p1">const chromaPass = new ShaderPass(new THREE.ShaderMaterial({</p>
<p class="p1"><span class="Apple-converted-space">  </span>uniforms:{ tDiffuse:{ value:null }, uAmount:{ value:.003 } },</p>
<p class="p1"><span class="Apple-converted-space">  </span>vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1);}`,</p>
<p class="p1"><span class="Apple-converted-space">  </span>fragmentShader:`uniform sampler2D tDiffuse;uniform float uAmount;varying vec2 vUv;</p>
<p class="p1"><span class="Apple-converted-space">  </span>void main(){vec2 r=vUv+(vec2(uAmount,0));vec2 g=vUv;vec2 b=vUv-(vec2(uAmount,0));</p>
<p class="p1"><span class="Apple-converted-space">  </span>gl_FragColor=vec4(texture(tDiffuse,r).r,texture(tDiffuse,g).g,texture(tDiffuse,b).b,1);}`</p>
<p class="p1">}));</p>
<p class="p1">composer.addPass(chromaPass);</p>
<p class="p2"><br></p>
<p class="p1">/* ---- 5. interacción / audio ---- */</p>
<p class="p1">let shape = 0;</p>
<p class="p1">window.addEventListener('click',()=&gt;{ shape=(shape+1)%3; simMat.uniforms.uShape.value = shape; });</p>
<p class="p1">navigator.mediaDevices?.getUserMedia({ audio:true }).then(stream=&gt;{</p>
<p class="p1"><span class="Apple-converted-space">  </span>const ctx=new AudioContext();</p>
<p class="p1"><span class="Apple-converted-space">  </span>const src=ctx.createMediaStreamSource(stream);</p>
<p class="p1"><span class="Apple-converted-space">  </span>const analyser=ctx.createAnalyser();</p>
<p class="p1"><span class="Apple-converted-space">  </span>src.connect(analyser);</p>
<p class="p1"><span class="Apple-converted-space">  </span>const data=new Uint8Array(analyser.frequencyBinCount);</p>
<p class="p1"><span class="Apple-converted-space">  </span>window.addEventListener('keydown',e=&gt;{if(e.key.toLowerCase()==='k'){shape=0;simMat.uniforms.uShape.value=0;}}); // Easter egg K</p>
<p class="p1"><span class="Apple-converted-space">  </span>function loop(){</p>
<p class="p1"><span class="Apple-converted-space">    </span>analyser.getByteFrequencyData(data);</p>
<p class="p1"><span class="Apple-converted-space">    </span>const bass = data.slice(0,8).reduce((a,b)=&gt;a+b)/2048;</p>
<p class="p1"><span class="Apple-converted-space">    </span>points.material.uniforms.uPoint.value = .015 + bass*.05;</p>
<p class="p1"><span class="Apple-converted-space">    </span>requestAnimationFrame(loop);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>loop();</p>
<p class="p1">});</p>
<p class="p2"><br></p>
<p class="p1">/* ---- 6. render loop ---- */</p>
<p class="p1">let t=0;</p>
<p class="p1">function animate(){</p>
<p class="p1"><span class="Apple-converted-space">  </span>requestAnimationFrame(animate);</p>
<p class="p1"><span class="Apple-converted-space">  </span>t+=.002;</p>
<p class="p1"><span class="Apple-converted-space">  </span>simMat.uniforms.uTime.value = t;</p>
<p class="p1"><span class="Apple-converted-space">  </span>visMat.uniforms.uTime.value = t;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>renderer.setRenderTarget(write);</p>
<p class="p1"><span class="Apple-converted-space">  </span>renderer.render(simScene,simCam);</p>
<p class="p1"><span class="Apple-converted-space">  </span>[read,write]=[write,read];</p>
<p class="p1"><span class="Apple-converted-space">  </span>visMat.uniforms.tPos.value = read.texture;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>composer.render();</p>
<p class="p1">}</p>
<p class="p1">animate();</p>
<p class="p2"><br></p>
<p class="p1">/* ---- 7. responsivo ---- */</p>
<p class="p1">addEventListener('resize',()=&gt;{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); composer.setSize(innerWidth,innerHeight); });</p>
<p class="p1">&lt;/script&gt;</p>
<p class="p1">&lt;/body&gt;</p>
<p class="p1">&lt;/html&gt;</p>
</body>
</html>
